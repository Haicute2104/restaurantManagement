# ğŸ—ï¸ Kiáº¿n trÃºc há»‡ thá»‘ng

## 1. Tá»•ng quan kiáº¿n trÃºc

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Flutter Apps (Dart)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Customer    â”‚     Staff        â”‚        Admin             â”‚
â”‚   App        â”‚     App          â”‚         App              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Shared Business Logic                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Models   â”‚  Services  â”‚ Providers  â”‚   Widgets   â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                        â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Firebase Backend                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚   Auth   â”‚  Firestore   â”‚  Storage   â”‚ Functions  â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 2. Kiáº¿n trÃºc Frontend (Flutter)

### 2.1. Clean Architecture + Feature-first

```
lib/
â”œâ”€â”€ admin/              # Admin feature module
â”‚   â”œâ”€â”€ screens/
â”‚   â””â”€â”€ utils/
â”œâ”€â”€ customer/           # Customer feature module
â”‚   â”œâ”€â”€ screens/
â”‚   â””â”€â”€ providers/
â”œâ”€â”€ staff/              # Staff feature module
â”‚   â””â”€â”€ screens/
â””â”€â”€ shared/             # Shared code
    â”œâ”€â”€ models/         # Domain models
    â”œâ”€â”€ services/       # Business logic
    â”œâ”€â”€ providers/      # State management
    â”œâ”€â”€ widgets/        # Reusable UI
    â””â”€â”€ utils/          # Helpers
```

### 2.2. State Management: Riverpod

**Provider Types:**
- `Provider` - Immutable data
- `StateProvider` - Simple state
- `StreamProvider` - Real-time streams
- `FutureProvider` - Async operations

**Example:**
```dart
// Provide Firestore service
final firestoreServiceProvider = Provider<FirestoreService>(
  (ref) => FirestoreService()
);

// Stream active orders
final activeOrdersProvider = StreamProvider<List<Order>>((ref) {
  final service = ref.watch(firestoreServiceProvider);
  return service.getActiveOrders();
});
```

### 2.3. Models

**Data Models:**
- `Order` - ÄÆ¡n hÃ ng
- `MenuItem` - MÃ³n Äƒn
- `MenuCategory` - Danh má»¥c
- `OrderItem` - Item trong Ä‘Æ¡n
- `User` - NgÆ°á»i dÃ¹ng
- `DailyReport` - BÃ¡o cÃ¡o ngÃ y

**Serialization:**
```dart
class Order {
  final String orderId;
  final OrderStatus status;
  
  // From Firestore
  factory Order.fromFirestore(DocumentSnapshot doc) { ... }
  
  // To Firestore
  static Map<String, dynamic> toFirestore(Order order) { ... }
}
```

---

## 3. Kiáº¿n trÃºc Backend (Firebase)

### 3.1. Firebase Services

#### Authentication
```
- Email/Password authentication
- User roles: customer, staff, admin
- Session management
```

#### Cloud Firestore
```
Collections:
- users: User profiles vÃ  roles
- menuCategories: Danh má»¥c thá»±c Ä‘Æ¡n
- menuItems: MÃ³n Äƒn
- orders: ÄÆ¡n hÃ ng (real-time)
- dailyReports: Thá»‘ng kÃª ngÃ y
```

#### Security Rules
```javascript
// Staff vÃ  Admin cÃ³ thá»ƒ update orders
allow update: if isSignedIn() && (
  getUserRole() in ['staff', 'admin'] || 
  request.auth.uid == resource.data.userId
);
```

### 3.2. Firestore Data Structure

```
firestore/
â”‚
â”œâ”€â”€ users/
â”‚   â””â”€â”€ {userId}
â”‚       â”œâ”€â”€ uid: string
â”‚       â”œâ”€â”€ email: string
â”‚       â”œâ”€â”€ role: 'customer' | 'staff' | 'admin'
â”‚       â””â”€â”€ displayName: string
â”‚
â”œâ”€â”€ menuCategories/
â”‚   â””â”€â”€ {categoryId}
â”‚       â”œâ”€â”€ name: string
â”‚       â””â”€â”€ priority: number
â”‚
â”œâ”€â”€ menuItems/
â”‚   â””â”€â”€ {itemId}
â”‚       â”œâ”€â”€ name: string
â”‚       â”œâ”€â”€ categoryId: string
â”‚       â”œâ”€â”€ price: number
â”‚       â”œâ”€â”€ imageUrl: string
â”‚       â””â”€â”€ isAvailable: boolean
â”‚
â”œâ”€â”€ orders/
â”‚   â””â”€â”€ {orderId}
â”‚       â”œâ”€â”€ userId: string
â”‚       â”œâ”€â”€ tableNumber: number
â”‚       â”œâ”€â”€ status: OrderStatus
â”‚       â”œâ”€â”€ items: OrderItem[]
â”‚       â”œâ”€â”€ totalAmount: number
â”‚       â”œâ”€â”€ notes: string
â”‚       â”œâ”€â”€ createdAt: Timestamp
â”‚       â””â”€â”€ updatedAt: Timestamp
â”‚
â””â”€â”€ dailyReports/
    â””â”€â”€ {YYYY-MM-DD}
        â”œâ”€â”€ totalRevenue: number
        â”œâ”€â”€ totalOrders: number
        â”œâ”€â”€ hourlyRevenue: Map<hour, revenue>
        â””â”€â”€ itemSalesCount: Map<itemId, count>
```

---

## 4. Design Patterns

### 4.1. Repository Pattern
```dart
class FirestoreService {
  final FirebaseFirestore _firestore;
  
  // Abstraction layer for Firestore operations
  Stream<List<Order>> getActiveOrders() { ... }
  Future<void> updateOrderStatus(...) { ... }
}
```

### 4.2. Provider Pattern (Dependency Injection)
```dart
// Inject services via Riverpod providers
final firestoreService = ref.watch(firestoreServiceProvider);
```

### 4.3. Observer Pattern
```dart
// Real-time listeners via Firestore streams
StreamBuilder<List<Order>>(
  stream: firestoreService.getActiveOrders(),
  builder: (context, snapshot) { ... }
)
```

---

## 5. Real-time Architecture

### 5.1. Data Flow

**Order Creation:**
```
Customer App
  â†“ create order
Firestore (orders collection)
  â†“ stream listener
Staff App (instant update)
Admin Dashboard (instant update)
```

**Order Status Update:**
```
Staff App
  â†“ update status
Firestore (orders collection)
  â†“ stream listener
Customer App (instant update)
Admin Dashboard (instant update)
```

### 5.2. Stream Architecture
```dart
// Provider setup
final activeOrdersProvider = StreamProvider<List<Order>>((ref) {
  return FirestoreService().getActiveOrders(); // Returns Stream
});

// UI consumption
final ordersAsync = ref.watch(activeOrdersProvider);
ordersAsync.when(
  data: (orders) => ListView(...),
  loading: () => LoadingIndicator(),
  error: (e, _) => ErrorView(error: e),
);
```

---

## 6. Security Architecture

### 6.1. Authentication Flow
```
1. User login â†’ Firebase Auth
2. Get user document from Firestore
3. Check role (customer/staff/admin)
4. Route to appropriate app
5. Apply role-based access control
```

### 6.2. Firestore Security
```javascript
function getUserRole() {
  return get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role;
}

match /orders/{orderId} {
  allow read: if isSignedIn();
  allow create: if isSignedIn();
  allow update: if getUserRole() in ['staff', 'admin'];
  allow delete: if getUserRole() == 'admin';
}
```

---

## 7. Scalability Considerations

### 7.1. Database Indexing
```
Composite indexes for:
- orders: (status + createdAt)
- orders: (userId + createdAt)
```

### 7.2. Query Optimization
```dart
// Filter in memory instead of complex Firestore queries
final activeOrders = await orders
  .where('status', whereIn: ['pending', 'confirmed', 'preparing', 'ready'])
  .get();
  
// Then sort in memory
orders.sort((a, b) => a.createdAt.compareTo(b.createdAt));
```

### 7.3. Pagination (Future)
```dart
// Implement pagination for large order lists
query.limit(20).startAfter(lastDoc);
```

---

## 8. Performance Optimization

### 8.1. Widget Optimization
```dart
// Use const constructors
const LoadingIndicator()

// Use keys for list items
ListView.builder(
  itemBuilder: (context, index) {
    return Card(key: ValueKey(order.orderId), ...);
  }
)
```

### 8.2. Stream Optimization
```dart
// Use StreamProvider for caching
// Riverpod automatically caches stream data
final ordersAsync = ref.watch(activeOrdersProvider);
```

### 8.3. Image Optimization
```dart
// Use cached_network_image for menu images
CachedNetworkImage(
  imageUrl: menuItem.imageUrl,
  placeholder: (context, url) => CircularProgressIndicator(),
)
```

---

## 9. Error Handling

### 9.1. Try-Catch Pattern
```dart
try {
  await firestoreService.updateOrderStatus(...);
  showSuccessMessage();
} catch (e) {
  showErrorMessage(e.toString());
}
```

### 9.2. Stream Error Handling
```dart
ordersAsync.when(
  data: (orders) => buildList(orders),
  loading: () => LoadingIndicator(),
  error: (error, stackTrace) => ErrorView(error: error),
);
```

---

## 10. Testing Architecture (Future)

### 10.1. Unit Tests
```dart
test('Order total amount calculation', () {
  final order = Order(...);
  expect(order.totalAmount, equals(100000));
});
```

### 10.2. Widget Tests
```dart
testWidgets('Menu screen displays items', (tester) async {
  await tester.pumpWidget(MenuScreen());
  expect(find.byType(MenuItemCard), findsWidgets);
});
```

### 10.3. Integration Tests
```dart
// Test full user flow
testWidgets('Complete order flow', (tester) async {
  // Login â†’ Select items â†’ Place order â†’ Verify
});
```


